#!/bin/bash

# SSH local forwarding
# -N Do not execute a remote command. This is useful for just forwarding ports.
# Local(127.0.0.1) -> Jump server(172.18.20.226) -> Remote(10.40.1.101)
# ssh -N -L 127.0.0.1:8888:10.40.1.101:22 test@172.18.20.226

# Variables
script_name=$(basename $0)
ssh_port=22
login_user="admin"
password=""
fgt_expect_root="# "
fgt_expect_user="$ "
fgt_expect=$fgt_expect_user
fgt_target="fgt1"
max_iterations=2
# Print Pretty
user_notation="@@@@"
separator="----------------------------------------------------------------"

usage() {
cat << _EOF
jssh 0.0

usage:
    $script_name [-P ssh_port] [-u user] [-p password] [-E fgt_expect] -t fgt_target/fgt_ip

Options:
    -P ssh_port         SSH port to use. Default is "$ssh_port"
    -u user             User to use for login. Default is "$login_user"
    -p password         Password to use for login. Default is "$password"
    -E fgt_expect       Except prompt to expect(other than "$fgt_expect_root"). Default is "$fgt_expect_user".
    -t fgt_target/fgt_ip  The device to connect to. Default is "$fgt_target"

Example:
    $script_name -t fpx1
    $script_name -u admin -p 123 -t fgt1 -p 22
    $script_name -u admin -p 123 -t 172.16.67.181

_EOF
    exit 0
}

[[ $# -eq 0 ]] && usage

# Parse command-line options
while getopts "p:u:t:P:E:h" opt; do
    case ${opt} in
        p)
            password=$OPTARG
            ;;
        u)
            login_user=$OPTARG
            ;;
        t)
            fgt_target=$OPTARG
            ;;
        E)
            fgt_expect=$OPTARG
            ;;
        P)
            ssh_port=$OPTARG
            ;;
        h)
            usage
            ;;
        ?)
            echo "$user_notation Invalid option: -$OPTARG" >&2
            exit 1
            ;;
    esac
done

# Shift to process non-option arguments. New $1, $2, ..., $@
shift $((OPTIND - 1))
if [[ $# -gt 0 ]]; then
    echo "$user_notation Illegal non-option arguments: $@"
    exit
fi

echo $separator
echo "$user_notation Set Target Device to: $fgt_target"
echo "$user_notation Set SSH Connection Port to: $ssh_port"
echo "$user_notation Set Username to: $login_user"
echo "$user_notation Set Password to: $password"
echo "$user_notation Connecting to $fgt_target..."
echo $separator

# expect -d -c "
expect -c "
    set timeout 5
    for {set i 1} {\$i <= $max_iterations} {incr i} {
        # ssh -o StrictHostKeyChecking=no $fgt_target
        # send_user \"Sync attempt \$i/$max_iterations\n\"
        spawn -noecho ssh -p $ssh_port $login_user@$fgt_target

        expect {
            {yes/no} {
                send \"yes\r\"
                exp_continue
            }
            -re {[Pp]assword} {
                send \"$password\r\"
                exp_continue
            }
            \"Host key verification failed.\" {
                send_user \"$user_notation Host key verification failed. Updating known_hosts file...\n\"
                system \"ssh-keygen -R $fgt_target\"
                send_user \"$user_notation Host key removed from known_hosts file.\n\"
                send_user \"$user_notation Retrying SSH immediately...\n\"
                continue
            }
            \"Permission denied\" {
                send_user \"$user_notation Permission denied. Have you specified the login credentials?\n\"
                exit 1
            }
            \"Connection refused\" {
                send_user \"$user_notation Connection refused. Action aborted.\n\"
                exit 1
            }
            eof {
                send_user \"$user_notation Reached EOF. Program ended.\n\"
                exit 1
            }
            timeout {
                send_user \"$user_notation Timed out waiting for a response.\n\"
                exit 1
            }
            \"$fgt_expect_root\" {
                break
            }
            \"$fgt_expect\" {
                break
            }
        }
    }

    send_user \"$user_notation Successfully connected to $fgt_target.\"
    send \"\r\"
    # Interact with the device
    interact
"

# + expect -d -c '
#     for {set i 1} {$i <= 2} {incr i} {
#         # ssh -o StrictHostKeyChecking=no 172.18.20.230
#         # send_user "Sync attempt $i/2\n"
#         spawn -noecho ssh admin@172.18.20.230

#         expect {
#             {yes/no} {
#                 send "yes\r"
#                 exp_continue
#             }
#             -re {[Pp]assword} {
#                 send "\r"
#                 exp_continue
#             }
#             "Host key verification failed." {
#                 send_user "@@@@ Host key verification failed. Updating known_hosts file...\n"
#                 system "ssh-keygen -R 172.18.20.230"
#                 send_user "@@@@ Host key removed from known_hosts file.\n"
#                 send_user "@@@@ Retrying SSH immediately...\n"
#                 continue
#             }
#             "Connection refused" {
#                 send_user "@@@@ Connection refused. Exiting...\n"
#                 exit 1
#             }
#             eof {
#                 puts "Reached EOF. Exiting..."
#                 exit 1
#             }
#             timeout {
#                 puts "Timed out waiting for a response."
#                 exit 1
#             }
#             "# " {
#                 puts "@@@@ Successfully connected to 172.18.20.230"
#                 break
#             }
#         }
#     }

#     send "\r"
#     expect "# "

#     # Now you can add additional commands or interactions as needed
#     # For example, you can automate further commands here

#     # Interact with the device
#     interact
# '
