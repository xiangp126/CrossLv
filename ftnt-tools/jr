#!/bin/bash
# set -x

# Variables
fEditor="code"
fDebug=0
fOnlyRg=0
fzfSelected=""
# Constants
SCRIPTNAME=$(basename $0)
SEPARATOR_LEFT="<---------------------------------------------------"
SEPARATOR_RIGHT="--------------------------------------------------->"
# USER_NOTATION="@@@@"
# Colors
MAGENTA='\033[35m'
NORMAL='\033[0m'
BOLD='\033[1m'
BLUE='\033[34m'
RESET='\033[0m'
COLOR=$MAGENTA

usage() {
    cat << _EOF_
$SCRIPTNAME v0.0

Usage: $SCRIPTNAME [vzd] <search term>

Options:
    -z  Search with empty query (you can also use jz command directly)
    -v  Open the file with vim (default is $fEditor)
    -d  Print debug information
    -r  Only use rg to search, not use fzf

Example: $SCRIPTNAME "search term"
         $SCRIPTNAME -z

Notice: The search term must be the last argument!

_EOF_
    exit 1
}

[[ $# -eq 0 ]] && usage

# parse the arguments, -v is for vim, -c is for code
while getopts "hvdrz" opt; do
    case ${opt} in
        v)
            fEditor="vim"
            ;;
        z)
            query=""
            ;;
        d)
            fDebug=1
            ;;
        r)
            fOnlyRg=1
            ;;
        h)
            usage
            ;;
        ?)
            echo "Invalid option: $OPTARG" 1>&2
            exit 1
            ;;
    esac
done

# OPTIND is a special variable used by getopts
# that keeps track of the next index in the positional parameters to be processed.
# After processing options, OPTIND will point to the first non-option argument.
shift $((OPTIND -1))
# [[ $# -gt 1 ]] && usage

query="$@"

checkDependencies() {
    local dependencies=("rg" "fzf" "bat" "$fEditor")
    for dep in "${dependencies[@]}"; do
        (command -v "$dep" &>/dev/null || echo "$dep is not installed") &
    done
    wait
}

parserAndPolish() {
    [[ -z "$query" ]] && return
    local param
    param=$(echo "$query" | sed -E 's/^[[:space:]]*|[[:space:]]*$//g; s/^[&!]//; s/;$//; s/^<|>$//g; s/:[0-9]+$//')
    query="$param"
}

searchAndOpen() {
    # --glob='*.{c,h,cpp,js,ts,py,html,css,sh,php}'
    local rgNullQueryExtraGlob="--glob='*.{c}'"
    local rgParams="--smart-case \
                    --color=ansi \
                    --colors 'match:fg:204,51,153' --colors 'match:style:bold' \
                    --line-number \
                    --no-heading \
                    --glob='!fpx-sync/*' \
                    --glob='!linux-*/*' \
                   "
    local fzfParams="--ansi \
                     --color 'hl:-1:underline,hl+:-1:underline:reverse' \
                     --delimiter ':' \
                     --preview 'bat --color=always {1} --theme=\"TwoDark\" --highlight-line {2}' \
                     --preview-window 'top,60%,border-bottom,+{2}+3/3,~3' \
                     --cycle \
                    "
    if [ -z "$query" ]; then
        rgParams="$rgParams $rgNullQueryExtraGlob"
    fi

    # Squash multiple whitespaces
    rgParams=$(echo "$rgParams" | tr -s ' ')
    fzfParams=$(echo "$fzfParams" | tr -s ' ')

    # Make the query command
    rgQuery="rg $rgParams \"$query\""
    # Remove the backslashes from the fzf query. Only fzf needs to remove the backslashes
    fzfQuery="fzf $fzfParams --query \"${query//\\/}\""

    # Debugging
    if [ $fDebug -ge 1 ]; then
        echo $SEPARATOR_RIGHT
        echo -e "rgQuery: ${COLOR}$rgQuery${RESET}"
        echo -e "fzfQuery: ${COLOR}$fzfQuery${RESET}"
        echo $SEPARATOR_LEFT
    fi

    if [ -z "$query" ]; then
        fzfSelected=$(eval "$rgQuery" | eval "$fzfQuery")
    else
        rgResult=$(eval "$rgQuery")
        if [ -z "$rgResult" ]; then
            echo -e "No result found for query: ${COLOR}$query${RESET}"
            exit 1
        fi
        [ $fOnlyRg -eq 1 ] && echo "$rgResult" && exit 0
        fzfSelected=$(echo "$rgResult" | eval "$fzfQuery")
    fi

    [ -z "$fzfSelected" ] && exit 0

    # Sample output of fzfResult:
    # daemon/wad/wad_app_eng.c:3071:          goto session_make_failed;
    pattern='([a-zA-Z0-9/.%_-]+):([0-9]+)'
    if [[ $fzfSelected =~ $pattern ]]; then
        file="${BASH_REMATCH[1]}"
        linenumber="${BASH_REMATCH[2]}"
    else
        echo -e "${COLOR}Error: The result is in unexpected format${RESET}"
        exit 1
    fi

    if [ "$fEditor" == "vim" ]; then
        $fEditor +"${linenumber}" "$file"
        exit 0
    else
        $fEditor "$file":"$linenumber"
    fi
}

checkDependencies
parserAndPolish
searchAndOpen

if [ -n "$fzfSelected" ];
then
    # echo -e "The file opened: ${COLOR}$file:$linenumber${RESET}"
    echo -e "The line opened: ${COLOR}$fzfSelected${RESET}"
fi
